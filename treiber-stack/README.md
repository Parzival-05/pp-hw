# Эксперимент

Эксперимент проводился с использованием `Ryzen 5 5500U 2.1GHz`, `16GB ОЗУ`, `Windows 11 v. 23H2`, версии и
используемые библиотеки указаны в файле [build.gradle.kts](build.gradle.kts), все запуски с использованием 12-ти
потоков и единственным параметром JVM — `-Xmx10G` для увелечения стека.

Стек с элиминацией — улучшение стека Трайбера, основанная на идеи устранения комплементарных операций `PUSH + POP`,
которые можно обработать, не взаимодействуя со стеком. Для этого в исходный стек вводятся три новые сущности (вкратце):

1. `Exchanger`, реализующий лишь один метод — `exchange` — для выполнения элиминации, при возможности.
2. `EliminationArray` — массив, который хранит объекты `Exchanger` для потоков, пытающихся выполнить операцию `PUSH`.
3. `RangePolicy` реализует стратегию для определения диапазона элементов в стеке, с которыми может происходить
   элиминация. Ширина диапазона влияет на то, как часто происходит фактическое обращение к стеку, т.е. с изменением
   интенсивности нагрузки может быть важным изменение этой величины.

Хотелось бы исследовать следующие вопросы:

- Какие параметры для стека с элиминацией покажут лучшую производительность?
    1. Время на попытку элиминации — `duration`
    2. Начальная и максимальная длина массива `EliminationArray` — `CAPACITY`.
- Какой прирост производительности по сравнению со стеком Трайбера?
- В каких сценариях такая оптимизация показывает лучшие результаты?

В [работе Casper W.](https://www.cs.vu.nl/~wanf/theses/woudenberg-bscthesis.pdf) удалось получить ускорение в 12
раз с операциямим в случайно порядке в сравнении со стеком Трайбера.

# Подбор параметров

Измерим то, как влияют `Duration` и `CAPACITY` на выполнение операций в случайном порядке.

- Для 30 запусков выведем среднее и СО
- Предварительно с помощью метода [IQR](https://en.wikipedia.org/wiki/Interquartile_range) избавимся от всплесков в
  собранных данных
- На каждый поток приходится `10^6` операций
- Изначально в стеке будет находиться `12` * `10^6` значений, чтобы не извлечь голову из пустого стека
- Стек типа `Int`

[Таблица с результатами](https://docs.google.com/spreadsheets/d/1DTobAr-UhOyjFJyWiZ-hPgfPGe-Z2Jd9JEGzOe_1x-U/edit?hl=ru#gid=0)

Измерения проводились лишь для некоторых значений, т.к. по имеющимся данным стало ясно, что при `CAPACITY` = `8`
достигается самое оптимальное соотношение между количеством конкурирующих операций и размером массива. Так
при `Duration` = `5` стек c элиминацией в среднем справляется с задачей за `0,16042` секунд. Далее для измерений будем
пользоваться этим результатом.

# Сравнение со стеком Трайбера

Сравним скорость выполнения со стеком Трайбера. Условия такие же, как и выше, но запусков 100.
Так же сравним скорость выполнения в разных случаях:

1. `PUSH-POP` — операции в потоке чередуются
2. `PUSH-PUSH-POP-POP`
3. `PUSH-PUSH-POP`
4. `PUSH-PUSH-PUSH-POP`
5. `(49 * PUSH)-POP` (49 раз PUSH и 1 POP)

<h3>Предположение</h3>

При определенных сценариях, например, 1 и 2 элиминация может выполняться чаще, т.к. увеличивается количество
потенциально устранимых операций, за счет чего
прирост от оптимизации должен быть еще больше. При неравномерном количестве операций POP и PUSH количество оптимизаций
должно уменьшиться, то есть ускорение
должно сходиться к 1.

<h3>Измерения</h3>

| 		Data		               | 	Elimination stack (s.)	 | 		SD	       | 	Treiber stack (s.)	 | 	SD 		      | 		Acceleration	 |
|------------------------|--------------------------|-------------|----------------------|-------------|-----------------|
| 		Random		             | 		0.17287			             | 		0.00536		 | 		1.28154			         | 		0.07372		 | 	7.41332		      |
| 		PUSH-POP		           | 		0.12608			             | 		0.00547		 | 		1.23823			         | 		0.06994		 | 	9.82099		      |
| 		PUSH-PUSH-POP		      | 		0.135			               | 		0.02332		 | 		1.3862			          | 		0.07099		 | 	10.26815		     |
| 		PUSH-PUSH-POP-POP		  | 		0.12678			             | 		0.00588		 | 		1.28331			         | 		0.06678		 | 	10.12234		     |
| 		PUSH-PUSH-PUSH-POP		 | 		0.34235			             | 		0.29667		 | 		1.73541			         | 		0.35694		 | 	5.06911		      |
| 		(49 * PUSH)-POP		    | 		0.42258			             | 		0.38276		 | 		1.97025			         | 		0.41011		 | 	4.66243		      |

<h3>Обсуждение</h3>

- В случаях 1, 2, 3 удалось получить существенное ускорение в 10 раз, что можно было ожидать — пропорция операций `PUSH` и `POP` должна быть примерно в (`1/1`, `2/1`). 
- На `3/1` (случай 4) элиминация дает ускорение вдвое меньше — всего в 5 раз, что понятно — количество оптимизаций снижается. Занятно то, что замедлился и стек Трайбера — c 1.2 c. до 1.7 с (40%). Возможно, для него `PUSH` является более тяжелой операцией.
- В случае 5 ускорение осталось примерно равным результату в 4, но относительно самой благоприятной ситуации (случай 1) стек работает в 3.5 раза медленнее, что ожидаемо.
- В двух последних случаях сильно возросло стандартное отклонение. Видимо, от большого количества PUSH'а  памяти стало недоставать, из-за своппинга производительность несколько упала и получился большой разброс по значениям.

# Результаты

В ходе данного эксперимента было изучено влияние оптимизации с элиминацией на производительность и рассмотрены некоторые
вопросы:

- Эмпирически для операций в случайном порядке получены оптимальные параметры стека.
- В сравнении со стеком Трайбера при интенсивной нагрузке и случайном порядке операций в среднем можно получить прирост
  в `7.4` раза, что несколько не сходится с известными результатами.
- При специфичных сценариях, благоприятных для такой стратегии, удалось получить еще больший прирост —
  в `10` раз. Это сценарии, при которых отношение количества операций `PUSH` к `POP` лежит в `[1, 2]`.
